// Generated by ChatGPT Version 5 Thinking
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.FileProviders;
using Microsoft.JSInterop;
using System.Text;
using System.Text.RegularExpressions;

namespace BedBrigade.Client.Components.Pages.Administration.Admin;

public partial class ViewLogs : ComponentBase, IAsyncDisposable
{
    [Inject] protected IConfiguration Config { get; set; } = default!;
    [Inject] protected IWebHostEnvironment Env { get; set; } = default!;
    [Inject] protected IJSRuntime JS { get; set; } = default!;
    protected List<LogFileOption> LogFiles { get; private set; } = new();
    protected string? SelectedLogPath { get; set; }
    protected bool ShowDebug { get; set; } = true;
    protected bool ShowInfo { get; set; } = true;
    protected bool ShowWarn { get; set; } = true;
    protected bool ShowError { get; set; } = true;

   
    protected bool IsTailing { get; private set; }
    protected bool IsLoading { get; private set; }
    protected string? LoadError { get; private set; }

    protected readonly List<LogEvent> AllEntries = new(capacity: 1024);
    protected List<LogEvent> FilteredEntries => ApplyLevelFilter(AllEntries);
    protected ElementReference LogContainerRef;

    // --- tailing state
    private FileStream? _stream;
    private long _lastReadPosition;
    private CancellationTokenSource? _tailCts;
    private Task? _tailLoopTask;
    private readonly object _lock = new();
    private readonly Regex _entryStart = new(
        @"^(?<ts>\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\.\d{3}\s[+\-]\d{2}:\d{2}),\s\[(?<level>[A-Za-z]+)\],\s\[(?<source>[^\]]*)\],\s\[(?<event>[^\]]*)\],\s\[User=(?<user>[^\]]*)\],\s(?<message>.*)$",
        RegexOptions.Compiled);

    private string? _logDir;
    private string _baseFileName = "Log.txt"; // from configuration
    private string _baseNameNoExt = "Log";
    private bool _shouldTail = true;
    private const string Error = "Error";
    private const string Warning = "Warning";
    private const string Information = "Information";
    private const string Debug = "Debug";
    protected bool ShouldTail
    {
        get
        {
            return _shouldTail;
        }
        set
        {
            _shouldTail = value;

            if (!_shouldTail && IsTailing)
            {
                StopTailing();
            }
            else if (_shouldTail && !IsTailing && SelectedLogPath is not null)
            {
                TryStartTailIfCurrent(SelectedLogPath);
            }
        }
    } 

    protected override async Task OnInitializedAsync()
    {
        try
        {
            ResolveLogDirectoryAndBaseName();
            DiscoverLogFiles();

            // pick today's file (or the most recent one)
            var today = DateOnly.FromDateTime(DateTime.Now);
            var todayCandidate = LogFiles.FirstOrDefault(f => f.IsToday) ?? LogFiles.FirstOrDefault();
            SelectedLogPath = todayCandidate?.FullPath;

            if (SelectedLogPath is not null)
            {
                await LoadFileAsync(SelectedLogPath);
                TryStartTailIfCurrent(SelectedLogPath);
            }
        }
        catch (Exception ex)
        {
            LoadError = ex.Message;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ScrollToBottomAsync();
        }
    }

    protected async Task OnLogChanged(ChangeEventArgs e)
    {
        if (e.Value is null) return;

        await LoadFileAsync(e.Value.ToString());
        TryStartTailIfCurrent(e.Value.ToString());
    }

    private void ResolveLogDirectoryAndBaseName()
    {
        // Find the File sink path from Serilog config (works with your attached JSONs)
        // Examples:
        //   Local:       ..\Logs\Log.txt
        //   Dev/Prod:    .\Logs\Log.txt
        // (rollingInterval is Day)  :contentReference[oaicite:3]{index=3} :contentReference[oaicite:4]{index=4} :contentReference[oaicite:5]{index=5}
        var writeToSection = Config.GetSection("Serilog:WriteTo");
        foreach (var child in writeToSection.GetChildren())
        {
            var name = child.GetValue<string>("Name");
            if (!string.Equals(name, "File", StringComparison.OrdinalIgnoreCase))
                continue;

            var path = child.GetSection("Args").GetValue<string>("path");
            if (string.IsNullOrWhiteSpace(path)) continue;

            // Normalize relative to ContentRoot
            var full = Path.GetFullPath(Path.Combine(Env.ContentRootPath, path));
            _logDir = Path.GetDirectoryName(full)!;
            _baseFileName = Path.GetFileName(full);
            _baseNameNoExt = Path.GetFileNameWithoutExtension(_baseFileName);
            return;
        }

        throw new InvalidOperationException("Could not resolve Serilog file sink path from configuration.");
    }

    private void DiscoverLogFiles()
    {
        LogFiles.Clear();
        if (_logDir is null || !Directory.Exists(_logDir)) return;

        // Serilog's daily rolling will produce files like:
        //   Log.txt (depending on sink config) and/or LogyyyyMMdd.txt
        // We'll include anything that looks like the base name.
        var pattern = $"{_baseNameNoExt}*.txt";
        var files = Directory.GetFiles(_logDir, pattern, SearchOption.TopDirectoryOnly);

        foreach (var f in files)
        {
            var fi = new FileInfo(f);
            var isToday = fi.LastWriteTime.Date == DateTime.Now.Date
                          || Path.GetFileName(f).Contains(DateTime.Now.ToString("yyyyMMdd"));
            LogFiles.Add(new LogFileOption
            {
                FullPath = f,
                DisplayName = Path.GetFileName(f),
                LastWrite = fi.LastWriteTime,
                IsToday = isToday
            });
        }

        // If nothing matched (edge cases), also probe plain "Log.txt"
        var fallback = Path.Combine(_logDir, _baseFileName);
        if (LogFiles.Count == 0 && File.Exists(fallback))
        {
            var fi = new FileInfo(fallback);
            LogFiles.Add(new LogFileOption
            {
                FullPath = fallback,
                DisplayName = Path.GetFileName(fallback),
                LastWrite = fi.LastWriteTime,
                IsToday = fi.LastWriteTime.Date == DateTime.Now.Date
            });
        }

        LogFiles = LogFiles.OrderByDescending(f => f.LastWrite).ToList();
    }

    private async Task LoadFileAsync(string fullPath)
    {
        StopTailing();

        IsLoading = true;
        LoadError = null;
        AllEntries.Clear();
        StateHasChanged();

        try
        {
            // read safely while Serilog might still be writing
            using var fs = new FileStream(fullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            using var sr = new StreamReader(fs, Encoding.UTF8);

            var content = await sr.ReadToEndAsync();
            ParseAndAppend(content);
        }
        catch (Exception ex)
        {
            LoadError = ex.Message;
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private void TryStartTailIfCurrent(string fullPath)
    {
        var selected = LogFiles.FirstOrDefault(l => l.FullPath == fullPath);
        if (selected is null) return;

        if (selected.IsToday)
        {
            StartTailing(fullPath);
        }
        else
        {
            StopTailing();
        }
    }

    private void StartTailing(string fullPath)
    {
        StopTailing();

        try
        {
            InitializeTail(fullPath);
            StartTailLoop(fullPath);
        }
        catch
        {
            StopTailing();
        }
        finally
        {
            InvokeAsync(StateHasChanged);
        }
    }

    private void InitializeTail(string fullPath)
    {
        _stream = new FileStream(fullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
        _lastReadPosition = _stream.Length; // start at end
        _tailCts = new CancellationTokenSource();
        IsTailing = true;
    }

    private void StartTailLoop(string fullPath)
    {
        var ct = _tailCts.Token;
        _tailLoopTask = Task.Run(() => TailLoopAsync(fullPath, ct), ct);
    }

    private async Task TailLoopAsync(string fullPath, CancellationToken ct)
    {
        var buffer = new byte[64 * 1024];
        var incomplete = new StringBuilder();

        while (!ct.IsCancellationRequested)
        {
            try
            {
                if (_stream is null) break;

                await TailIterationAsync(fullPath, buffer, incomplete, ct);
                await Task.Delay(1000, ct);
            }
            catch (TaskCanceledException) { /* expected on cancel */ }
            catch (Exception)
            {
                // ignore transient read issues during rolling
                await Task.Delay(1000, ct);
            }
        }
    }

    private async Task TailIterationAsync(
        string fullPath,
        byte[] buffer,
        StringBuilder incomplete,
        CancellationToken ct)
    {
        if (_stream is null) return;

        if (_stream.Length < _lastReadPosition)
        {
            ReopenStreamFromStart(fullPath, incomplete);
            return;
        }

        if (_stream.Length > _lastReadPosition)
        {
            await ReadAndProcessAsync(buffer, incomplete, ct);
        }
    }

    private void ReopenStreamFromStart(string fullPath, StringBuilder incomplete)
    {
        _stream?.Dispose();
        _stream = new FileStream(fullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
        _lastReadPosition = 0;
        incomplete.Clear();
    }

    private async Task ReadAndProcessAsync(
        byte[] buffer,
        StringBuilder incomplete,
        CancellationToken ct)
    {
        if (_stream is null) return;

        _stream.Seek(_lastReadPosition, SeekOrigin.Begin);

        var toRead = (int)Math.Min(buffer.Length, _stream.Length - _lastReadPosition);
        var read = await _stream.ReadAsync(buffer.AsMemory(0, toRead), ct);
        if (read <= 0) return;

        _lastReadPosition += read;
        var chunk = Encoding.UTF8.GetString(buffer, 0, read);
        incomplete.Append(chunk);

        await ProcessCompletedLinesAsync(incomplete);
    }

    private async Task ProcessCompletedLinesAsync(StringBuilder incomplete)
    {
        var text = incomplete.ToString();
        var lastNewline = text.LastIndexOf('\n');
        if (lastNewline < 0) return;

        var full = text[..(lastNewline + 1)];
        incomplete.Remove(0, lastNewline + 1);

        lock (_lock)
        {
            ParseAndAppend(full);
        }

        await RefreshUiAsync();
    }

    private async Task RefreshUiAsync()
    {
        await InvokeAsync(StateHasChanged);
        await ScrollToBottomAsync();
    }


    private void StopTailing()
    {
        IsTailing = false;
        try { _tailCts?.Cancel(); } catch { }
        try { _tailLoopTask?.Wait(250); } catch { }
        try { _tailCts?.Dispose(); } catch { }
        _tailCts = null;
        _tailLoopTask = null;

        if (_stream is not null)
        {
            try { _stream.Dispose(); } catch { }
            _stream = null;
        }
    }

    private void ParseAndAppend(string text)
    {
        using var reader = new StringReader(text);
        string? line;
        LogEvent? current = null;
        var block = new StringBuilder();

        while ((line = reader.ReadLine()) is not null)
        {
            if (TryStartNewEvent(line, ref current, block))
                continue;

            AppendContinuation(line, ref current, block);
        }

        if (current is not null)
            CommitEvent(current, block);
    }

    private bool TryStartNewEvent(string line, ref LogEvent? current, StringBuilder block)
    {
        var m = _entryStart.Match(line);
        if (!m.Success) return false;

        if (current is not null)
            CommitEvent(current, block);

        current = CreateEventFromMatch(m);
        block.Clear();
        block.Append(line).Append(Environment.NewLine);
        return true;
    }

    private void AppendContinuation(string line, ref LogEvent? current, StringBuilder block)
    {
        if (current is null)
        {
            current = CreateSyntheticDebug(line);
            block.Clear();
        }

        block.Append(line).Append(Environment.NewLine);
    }

    private LogEvent CreateEventFromMatch(Match m)
    {
        return new LogEvent
        {
            Timestamp = DateTimeOffset.TryParse(m.Groups["ts"].Value, out var dto) ? dto : null,
            Level = NormalizeLevel(m.Groups["level"].Value),
            SourceContext = m.Groups["source"].Value,
            EventId = m.Groups["event"].Value,
            UserId = m.Groups["user"].Value,
            Message = m.Groups["message"].Value
        };
    }

    private LogEvent CreateSyntheticDebug(string firstLine)
    {
        return new LogEvent
        {
            Level = "Debug",
            Message = firstLine
        };
    }

    private void CommitEvent(LogEvent current, StringBuilder block)
    {
        current.Raw = block.ToString().TrimEnd('\r', '\n');
        ExtractExceptionIfPresent(current);
        NormalizeLevelCss(current);
        AllEntries.Add(current);
    }

    private void ExtractExceptionIfPresent(LogEvent current)
    {
        if (string.IsNullOrWhiteSpace(current.Message))
            return;

        var raw = current.Raw ?? string.Empty;
        var idx = raw.IndexOf('\n');
        if (idx < 0) return;

        var afterFirst = raw[(idx + 1)..];
        current.Exception = afterFirst.TrimEnd();
    }

    private void NormalizeLevelCss(LogEvent current)
    {
        if (current.Level != Error &&
            current.Level != Warning &&
            current.Level != Information &&
            current.Level != Debug)
        {
            current.LevelCss = string.Empty;
        }
        else
        {
            current.LevelCss = current.Level;
        }
    }


    private static string NormalizeLevel(string raw) =>
        raw switch
        {
            "DBG" or "Debug" or "DEBUG" => Debug,
            "INF" or "Info" or "Information" => Information,
            "WRN" or "Warn" or "Warning" => Warning,
            "ERR" or "Error" or "ERROR" => Error,
            _ => raw
        };



    private List<LogEvent> ApplyLevelFilter(List<LogEvent> source)
    {
       return  source.Where(e =>
            (ShowDebug || e.Level != Debug) &&
            (ShowInfo || e.Level != Information) &&
            (ShowWarn || e.Level != Warning) &&
            (ShowError || e.Level != Error)
        ).ToList();
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("blazorScrollToBottom", LogContainerRef);
        }
        catch { /* no-op if container not yet rendered */ }
    }
    public async ValueTask DisposeAsync()
    {
        StopTailing();
        await Task.CompletedTask;
    }

    // --- types
    protected sealed class LogFileOption
    {
        public string FullPath { get; set; } = default!;
        public string DisplayName { get; set; } = default!;
        public DateTime LastWrite { get; set; }
        public bool IsToday { get; set; }
    }

    protected sealed class LogEvent
    {
        public DateTimeOffset? Timestamp { get; set; }
        public string Level { get; set; } = "";
        public string? SourceContext { get; set; }
        public string? EventId { get; set; }
        public string? UserId { get; set; }
        public string? Message { get; set; }
        public string? Exception { get; set; }
        public string? Raw { get; set; }
        public string LevelCss { get; set; } = "";
    }
}
